from typing import Any, Optional, Union, Tuple, overload, MutableMapping
import os

# Public dtype tokens (NumPy-like)
int16: str
int32: str
int_: str
float16: str
float32: str
float64: str
float_: str
bool_: str
bit: str

# Complex float dtype tokens (Phase 3)
complex_float16: str
complex_float32: str
complex_float64: str
complex64: str
complex128: str

class PyCausetWarning(UserWarning): ...
class PyCausetDTypeWarning(PyCausetWarning): ...
class PyCausetOverflowRiskWarning(PyCausetWarning): ...
class PyCausetPerformanceWarning(PyCausetWarning): ...
class PyCausetStorageWarning(PyCausetWarning): ...

class MatrixMixin:
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class VectorBase:
    def close(self) -> None: ...
    def copy_storage(self, result_file_hint: str = "") -> None: ...
    def size(self) -> int: ...
    def __len__(self) -> int: ...
    def get(self, i: int) -> Any: ...
    def set(self, i: int, value: Any) -> None: ...
    def __getitem__(self, i: int) -> Any: ...
    def __setitem__(self, i: int, value: Any) -> None: ...
    def get_backing_file(self) -> str: ...
    @property
    def backing_file(self) -> str: ...
    @property
    def shape(self) -> Tuple[int, ...]: ...
    @property
    def T(self) -> 'VectorBase': ...
    def transpose(self) -> 'VectorBase': ...
    def conj(self) -> 'VectorBase': ...
    @property
    def H(self) -> 'VectorBase': ...

    def is_transposed(self) -> bool: ...
    def is_conjugated(self) -> bool: ...
    def dot(self, other: 'VectorBase') -> Union[float, complex]: ...
    def __add__(self, other: Any) -> 'VectorBase': ...
    def __sub__(self, other: Any) -> 'VectorBase': ...
    def __mul__(self, other: Any) -> 'VectorBase': ...
    def __rmul__(self, other: Any) -> 'VectorBase': ...
    def __matmul__(self, other: Any) -> Any: ...

    @property
    def properties(self) -> MutableMapping[str, Any]: ...

    @properties.setter
    def properties(self, value: dict[str, Any]) -> None: ...

class FloatVector(VectorBase): ...
class Float16Vector(VectorBase): ...
class Float32Vector(VectorBase): ...
class IntegerVector(VectorBase): ...
class Int16Vector(VectorBase): ...
class BitVector(VectorBase): ...

class ComplexFloat16Vector(VectorBase): ...
class ComplexFloat32Vector(VectorBase): ...
class ComplexFloat64Vector(VectorBase): ...

class MatrixBase:
    def close(self) -> None: ...
    def copy_storage(self, result_file_hint: str = "") -> None: ...
    def size(self) -> int: ...
    def rows(self) -> int: ...
    def cols(self) -> int: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

    @property
    def properties(self) -> MutableMapping[str, Any]: ...

    @properties.setter
    def properties(self, value: dict[str, Any]) -> None: ...

    def get_backing_file(self) -> str: ...
    @property
    def backing_file(self) -> str: ...

    @property
    def T(self) -> 'MatrixBase': ...
    def transpose(self) -> 'MatrixBase': ...
    def conj(self) -> 'MatrixBase': ...
    @property
    def H(self) -> 'MatrixBase': ...

    def is_transposed(self) -> bool: ...
    def is_conjugated(self) -> bool: ...

    def get(self, i: int, j: int) -> Any: ...
    def set(self, i: int, j: int, value: Any) -> None: ...
    def multiply(self, other: 'MatrixBase') -> 'MatrixBase': ...
    def trace(self) -> Any: ...
    def determinant(self) -> Any: ...

    def __getitem__(self, key: Tuple[int, int]) -> Any: ...
    def __setitem__(self, key: Tuple[int, int], value: Any) -> None: ...
    def __matmul__(self, other: Any) -> Any: ...
    def __add__(self, other: Any) -> 'MatrixBase': ...
    def __radd__(self, other: Any) -> 'MatrixBase': ...
    def __iadd__(self, other: Any) -> 'MatrixBase': ...
    def __sub__(self, other: Any) -> 'MatrixBase': ...
    def __mul__(self, other: Any) -> 'MatrixBase': ...
    def __rmul__(self, other: Any) -> 'MatrixBase': ...

class TriangularBitMatrix(MatrixBase):
    def __init__(self, n: int) -> None: ...
    def get(self, i: int, j: int) -> bool: ...
    def set(self, i: int, j: int, value: bool) -> None: ...
    def size(self) -> int: ...
    def close(self) -> None: ...
    def get_backing_file(self) -> str: ...
    def multiply(self, other: 'TriangularBitMatrix') -> 'IntegerMatrix': ...
    def elementwise_multiply(self, other: 'TriangularBitMatrix') -> 'TriangularBitMatrix': ...
    def __getitem__(self, key: Tuple[int, int]) -> int: ...
    def __setitem__(self, key: Tuple[int, int], value: bool) -> None: ...
    @property
    def shape(self) -> Tuple[int, int]: ...
    @staticmethod
    def random(n: int, p: float, seed: Optional[int] = None) -> 'TriangularBitMatrix': ...

def causal_matrix(source: Any, populate: bool = True, **kwargs: Any) -> TriangularBitMatrix: ...

class IntegerMatrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...
    def get(self, i: int, j: int) -> int: ...
    def set(self, i: int, j: int, value: int) -> None: ...
    def size(self) -> int: ...
    def close(self) -> None: ...
    def get_backing_file(self) -> str: ...
    def __getitem__(self, key: Tuple[int, int]) -> int: ...
    def __setitem__(self, key: Tuple[int, int], value: int) -> None: ...
    def __matmul__(self, other: Any) -> Any: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

class Int16Matrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...
    def get(self, i: int, j: int) -> int: ...
    def set(self, i: int, j: int, value: int) -> None: ...
    def size(self) -> int: ...
    def close(self) -> None: ...
    def get_backing_file(self) -> str: ...
    def __getitem__(self, key: Tuple[int, int]) -> int: ...
    def __setitem__(self, key: Tuple[int, int], value: int) -> None: ...
    def __matmul__(self, other: Any) -> Any: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

class Float32Matrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...
    def get(self, i: int, j: int) -> float: ...
    def set(self, i: int, j: int, value: float) -> None: ...
    def __getitem__(self, key: Tuple[int, int]) -> float: ...
    def __setitem__(self, key: Tuple[int, int], value: float) -> None: ...
    def __matmul__(self, other: Any) -> Any: ...
    def inverse(self) -> 'Float32Matrix': ...
    def invert(self) -> 'Float32Matrix': ...
    def matmul(self, other: 'Float32Matrix') -> 'Float32Matrix': ...
    @property
    def shape(self) -> Tuple[int, int]: ...

class TriangularIntegerMatrix(MatrixBase):
    def __init__(self, n: int, has_diagonal: bool = False) -> None: ...
    def get(self, i: int, j: int) -> int: ...
    def set(self, i: int, j: int, value: int) -> None: ...
    def __getitem__(self, key: Tuple[int, int]) -> int: ...
    def __setitem__(self, key: Tuple[int, int], value: int) -> None: ...
    def __matmul__(self, other: Any) -> Any: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

class DenseBitMatrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...
    def get(self, i: int, j: int) -> bool: ...
    def set(self, i: int, j: int, value: bool) -> None: ...
    def __getitem__(self, key: Tuple[int, int]) -> int: ...
    def __setitem__(self, key: Tuple[int, int], value: bool) -> None: ...
    def __matmul__(self, other: Any) -> Any: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

class TriangularFloatMatrix(MatrixBase):
    def __init__(self, n: int, has_diagonal: bool = False) -> None: ...
    def get(self, i: int, j: int) -> float: ...
    def set(self, i: int, j: int, value: float) -> None: ...
    def size(self) -> int: ...
    def close(self) -> None: ...
    def get_backing_file(self) -> str: ...
    def __getitem__(self, key: Tuple[int, int]) -> float: ...
    @property
    def shape(self) -> Tuple[int, int]: ...

class FloatMatrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...
    def get(self, i: int, j: int) -> float: ...
    def set(self, i: int, j: int, value: float) -> None: ...

    def size(self) -> int: ...
    def close(self) -> None: ...
    def get_backing_file(self) -> str: ...
    def __getitem__(self, key: Tuple[int, int]) -> float: ...
    @property
    def shape(self) -> Tuple[int, int]: ...
    def inverse(self) -> 'FloatMatrix': ...
    def invert(self) -> 'FloatMatrix': ...
    def matmul(self, other: 'FloatMatrix') -> 'FloatMatrix': ...

class Float16Matrix(MatrixBase): ...

class ComplexFloat16Matrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...

class ComplexFloat32Matrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...

class ComplexFloat64Matrix(MatrixBase):
    @overload
    def __init__(self, n: int) -> None: ...
    @overload
    def __init__(self, rows: int, cols: int) -> None: ...

def matrix(source: Any, dtype: Any = None, **kwargs: Any) -> MatrixBase: ...

def vector(source: Any, dtype: Any = None, **kwargs: Any) -> VectorBase: ...

def zeros(shape: Any, *, dtype: Any, **kwargs: Any) -> Any: ...

def ones(shape: Any, *, dtype: Any, **kwargs: Any) -> Any: ...

def empty(shape: Any, *, dtype: Any, **kwargs: Any) -> Any: ...

def causet(*, n: int = ..., density: float = ..., spacetime: Any = ..., seed: Optional[Union[int, str]] = ..., matrix: Any = ...) -> Any: ...

def load(path: Union[str, os.PathLike[str]]) -> Any: ...

def save(matrix: Any, path: Union[str, os.PathLike]) -> None: ...

def compute_k(matrix: TriangularBitMatrix, a: float) -> TriangularFloatMatrix: ...

def matmul(a: Any, b: Any) -> Any: ...

def dot(a: VectorBase, b: VectorBase) -> Union[float, complex]: ...

def divide(a: Any, b: Any) -> Any: ...
def norm(x: Any) -> float: ...
def sum(x: Any) -> complex: ...

def invert(matrix: Any) -> Any: ...

def solve(a: Any, b: Any) -> Any: ...

def lstsq(a: Any, b: Any) -> Any: ...

def slogdet(a: Any) -> Tuple[float, float]: ...

def cond(a: Any, p: Any = ...) -> float: ...

def eigh(a: Any) -> Tuple[Any, Any]: ...

def eigvalsh(a: Any) -> Any: ...

def solve_triangular(*args: Any, **kwargs: Any) -> Any: ...
def lu(*args: Any, **kwargs: Any) -> Any: ...
def cholesky(*args: Any, **kwargs: Any) -> Any: ...
def svd(*args: Any, **kwargs: Any) -> Any: ...
def pinv(*args: Any, **kwargs: Any) -> Any: ...

def eig(*args: Any, **kwargs: Any) -> Any: ...
def eigvals(*args: Any, **kwargs: Any) -> Any: ...
def eigvals_skew(*args: Any, **kwargs: Any) -> Any: ...
def eigvals_arnoldi(*args: Any, **kwargs: Any) -> Any: ...

def _debug_resolve_promotion(op: str, a_dtype: str, b_dtype: str) -> dict[str, object]: ...

keep_temp_files: bool
seed: Optional[int]
